/*
Copyright 2018 Turbine Labs, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package assert

import (
	"fmt"
	"testing"
)

// G represents a (possibly nested) group of assertions. The Name field is
// used as a prefix to the error message generated by each assertion. G embeds
// a testing.TB, which may be a testing.T or a TracingTB (which itself embeds a
// testing.TB)
type G struct {
	testing.TB
	name string
}

// Group creates a group of assertions with a common error message
// prefix. The prefix holds only for assertion methods invoked with
// the G instance passed to the given function:
//
//     func TestThing(t *testing.T) {
//         Group("group-name", t, func(g *assert.G) {
//                 assert.True(g, true)
//         })
//     }
//
// Note that testing.TB is an interface implemented by testing.T.
func Group(name string, t testing.TB, f func(*G)) {
	group := &G{Tracing(t), name}
	f(group)
}

// Group creates a nested group of assertions with a common error
// message prefix.  The parent group's Name and the given name are
// joined with a space separator to form the prefix for the new
// group. The prefix holds only for assertion methods invoked on the G
// instance passed to this given function:
//
//     func TestThing(t *testing.T) {
//         Group("group-name", t, func(g *assert.G) {
//                 g.Group("nested-group-name", func(ng *assert.G) {
//                         assert.True(ng, true)
//                 })
//         })
//     }
func (grp *G) Group(name string, f func(*G)) {
	nestedName := fmt.Sprintf("%s %s", grp.Name(), name)
	nestedGrp := &G{Tracing(grp.TB), nestedName}
	f(nestedGrp)
}

// Name returns the name of the group.
func (grp *G) Name() string {
	return grp.name
}

// Errorf invokes the group's underlying testing.TB's Errorf function
// with the given error message and arguments.
func (grp *G) Errorf(format string, args ...interface{}) {
	if len(grp.Name()) > 0 {
		prefix := fmt.Sprintf("%s: ", grp.Name())
		format = prefix + format
	}

	grp.TB.Errorf(format, args...)
}

// Error invokes the group's underlying testing.TB's Error function
// with the given arguments.
func (grp *G) Error(args ...interface{}) {
	if len(grp.Name()) > 0 {
		newArgs := make([]interface{}, 1, len(args)+1)
		newArgs[0] = fmt.Sprintf("%s:", grp.Name())
		args = append(newArgs, args...)
	}

	grp.TB.Error(args...)
}

// Fatalf invokes the group's underlying testing.TB's Fatalf function
// with the given error message and arguments.
func (grp *G) Fatalf(format string, args ...interface{}) {
	if len(grp.Name()) > 0 {
		prefix := fmt.Sprintf("%s: ", grp.Name())
		format = prefix + format
	}

	grp.TB.Fatalf(format, args...)
}

// Fatal invokes the group's underlying testing.TB's Fatal function
// with the given arguments.
func (grp *G) Fatal(args ...interface{}) {
	if len(grp.Name()) > 0 {
		newArgs := make([]interface{}, 1, len(args)+1)
		newArgs[0] = fmt.Sprintf("%s:", grp.Name())
		args = append(newArgs, args...)
	}

	grp.TB.Fatal(args...)
}
